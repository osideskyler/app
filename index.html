<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NexusFlow - Enhanced Prototype</title>
    <style>
        /* --- Base Styles --- */
        :root {
            --bg-color: #f4f7fc;
            --primary-color: #6a11cb;
            --secondary-color: #2575fc;
            --accent-color: #34e89e;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --text-color: #333;
            --text-light: #f9f9f9;
            --border-color: #e0e0e0;
            --card-bg: #ffffff;
            --shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            --gradient-main: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* --- Dark Theme --- */
        body.dark-theme {
            --bg-color: #1f2023;
            --primary-color: #7e57c2; /* Lighter purple */
            --secondary-color: #42a5f5; /* Lighter blue */
            --accent-color: #66bb6a; /* Lighter green */
            --text-color: #e0e0e0;
            --text-light: #212121;
            --border-color: #424242;
            --card-bg: #2c2f33;
            --shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }


        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            font-size: 16px;
            transition: background-color 0.3s, color 0.3s;
        }
        .container { display: flex; flex-grow: 1; }
        header {
            background: var(--gradient-main);
            color: var(--text-light);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow);
        }
        header h1 { font-size: 1.8em; margin: 0; }
        .header-right { display: flex; align-items: center; gap: 20px;}

        /* --- Gamification Status --- */
        .gamification-status { display: flex; gap: 15px; font-weight: bold; align-items: center;}
        .gamification-status span { background-color: var(--accent-color); padding: 5px 10px; border-radius: 15px; color: var(--text-color); transition: background-color 0.3s, color 0.3s;}

        /* --- Sidebar --- */
        nav#sidebar {
            width: 240px; /* Slightly wider */
            background-color: var(--card-bg);
            padding: 1.5rem 1rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
            border-right: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
            display: flex;
            flex-direction: column;
        }
        nav#sidebar ul { list-style: none; margin-bottom: auto; /* Push theme toggle down */ }
        nav#sidebar li a {
            display: block; padding: 0.8rem 1rem; color: var(--text-color); text-decoration: none; border-radius: 5px; margin-bottom: 0.5rem; transition: background-color 0.2s ease, color 0.2s ease; font-weight: 500;
        }
        nav#sidebar li a:hover, nav#sidebar li a.active { background-color: var(--secondary-color); color: var(--text-light); }

        /* Theme Toggle */
         #theme-toggle { margin-top: 1rem; cursor: pointer; background: none; border: 1px solid var(--border-color); color: var(--text-color); padding: 0.5rem; border-radius: 5px; text-align: center; }


        /* --- Main Content --- */
        main#content { flex-grow: 1; padding: 2rem; overflow-y: auto; }
        .view { display: none; animation: fadeIn 0.5s ease-in-out; }
        .view.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- General UI Elements --- */
        h2 { margin-bottom: 1.5rem; color: var(--primary-color); font-size: 1.6em; border-bottom: 2px solid var(--border-color); padding-bottom: 0.5rem; }
        h3 { margin-top: 1.5rem; margin-bottom: 0.8rem; color: var(--secondary-color); border-bottom: 1px solid var(--border-color); padding-bottom: 0.3rem; }
        h3:first-of-type { margin-top: 0; }

        .input-group { margin-bottom: 1.5rem; background: var(--card-bg); padding: 1.5rem; border-radius: 8px; box-shadow: var(--shadow); border: 1px solid var(--border-color); transition: background-color 0.3s, border-color 0.3s;}
        .input-group label { display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--primary-color); }
        .input-group input[type="text"],
        .input-group input[type="date"],
        .input-group select,
        .input-group textarea {
            width: 100%; padding: 0.8rem; border: 1px solid var(--border-color); background-color: var(--bg-color); color: var(--text-color); border-radius: 4px; margin-bottom: 0.8rem; font-size: 1rem; transition: background-color 0.3s, color 0.3s;
        }
         .input-group textarea { min-height: 80px; }

        .btn {
            background: var(--secondary-color); color: var(--text-light); border: none; padding: 0.8rem 1.5rem; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; font-weight: bold; font-size: 1rem; display: inline-block; margin-right: 0.5rem; vertical-align: middle;
        }
         .btn:last-child { margin-right: 0; }
        .btn:hover { background-color: var(--primary-color); }
        .btn-delete { background-color: var(--danger-color); font-size: 0.8em; padding: 0.3rem 0.6rem; opacity: 0.8; }
        .btn-delete:hover { opacity: 1; background-color: #c0392b; }
        .btn-process, .btn-complete { background-color: var(--accent-color); color: var(--text-color); font-size: 0.8em; padding: 0.3rem 0.6rem;}
        .btn-process:hover, .btn-complete:hover { background-color: #27ae60; }
         .btn-small { padding: 0.4rem 0.8rem; font-size: 0.9rem; margin-left: 5px; }


        /* --- Lists (Goals, Tasks, Inbox, Habits, Notes) --- */
        .item-list { list-style: none; margin-top: 1.5rem; }
        .item-list li {
            background: var(--card-bg); padding: 1rem 1.5rem; margin-bottom: 1rem; border-radius: 8px; box-shadow: var(--shadow); border-left: 5px solid var(--primary-color); display: flex; flex-direction: column; /* Allow wrapping */ transition: all 0.2s ease-in-out; position: relative;
        }
         .item-list li:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        .item-list li .item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;}
         .item-list li .item-title { font-weight: 600; flex-grow: 1; margin-right: 10px;}
         .item-list li .item-actions button { margin-left: 5px; }
         .item-list li .item-details { font-size: 0.85em; color: #777; display: flex; gap: 15px; flex-wrap: wrap; margin-top: 0.5rem;}
        body.dark-theme .item-list li .item-details { color: #aaa; }
         .item-list li .item-details span { background-color: rgba(0,0,0,0.05); padding: 2px 6px; border-radius: 4px; }
         body.dark-theme .item-list li .item-details span { background-color: rgba(255,255,255,0.1); }
         .item-list li .item-note { font-style: italic; margin-top: 5px; font-size: 0.9em; }
         /* Sublists for goal hierarchy */
        .item-list ul { list-style: none; padding-left: 25px; margin-top: 10px; border-left: 1px dashed var(--border-color); }

         /* Specific Item Type Styling */
         .yearly-goal { border-left-color: var(--primary-color); }
         .monthly-goal { border-left-color: var(--secondary-color); }
         .weekly-goal { border-left-color: var(--accent-color); }
         .daily-task { border-left-color: var(--warning-color); }
         .inbox-item { border-left-color: #9b59b6; } /* Amethyst for Inbox */
         .habit-item { border-left-color: #1abc9c; } /* Turquoise for Habits */
        .note-item { border-left-color: #3498db; } /* Peter River for Notes */

         .daily-task.completed { border-left-color: #bdc3c7; opacity: 0.7; }
         .daily-task.completed .item-title { text-decoration: line-through; color: #aaa; }
         .daily-task input[type="checkbox"], .habit-item input[type="checkbox"] { margin-right: 10px; transform: scale(1.2); cursor: pointer; }


        /* --- Calendar View --- */
        #calendar-container { margin-top: 1rem; background: var(--card-bg); padding: 1.5rem; border-radius: 8px; box-shadow: var(--shadow); }
        #calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        #calendar-header button { background: none; border: 1px solid var(--border-color); color: var(--text-color); padding: 0.3rem 0.8rem; border-radius: 4px; cursor: pointer; }
        #month-year { font-size: 1.2em; font-weight: bold; color: var(--primary-color); }
        #calendar-grid { width: 100%; border-collapse: collapse; }
        #calendar-grid th, #calendar-grid td {
            border: 1px solid var(--border-color); padding: 0.8rem; text-align: center; width: 14.28%; /* 7 days */ height: 80px; /* Fixed height */ vertical-align: top; font-size: 0.9em;
        }
        #calendar-grid th { background-color: var(--bg-color); font-weight: bold; }
        #calendar-grid td { cursor: default; position: relative; } /* Might make clickable later */
        #calendar-grid .other-month { color: #aaa; background-color: rgba(128, 128, 128, 0.05); }
        #calendar-grid .today { background-color: var(--accent-color) !important; color: var(--text-color) !important; font-weight: bold; }
        .calendar-task-indicator {
            display: block; width: 8px; height: 8px; border-radius: 50%; background-color: var(--secondary-color); margin: 2px auto 0;
        }


        /* --- Gamification Visual --- */
        #gamification-visuals { margin-top: 2rem; text-align: center; }
        #plant-container { width: 100px; height: 150px; background-color: #8B4513; /* Pot color */ margin: 0 auto 10px; border-radius: 0 0 40px 40px; position: relative; }
        #plant-stem { width: 10px; height: 0; /* Grows with level */ background-color: #228B22; /* ForestGreen */ position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); transition: height 0.5s ease-out; border-radius: 5px 5px 0 0;}
        #plant-leaf { width: 0; height: 0; /* Simple leaf appears later */ border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 20px solid #32CD32; /* LimeGreen */ position: absolute; bottom: 20px; /* Adjust position based on stem */ left: 50%; transform: translateX(-50%) rotate(0deg); opacity: 0; transition: all 0.5s ease-out; }
        #badge-container { margin-top: 1rem; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
        .badge {
            background-color: var(--warning-color); color: var(--text-light); padding: 5px 10px; border-radius: 15px; font-size: 0.8em; display: inline-block; box-shadow: var(--shadow);
        }
         .badge[data-badge="visionary"] { background-color: var(--primary-color); }
         .badge[data-badge="inbox_zero"] { background-color: #9b59b6; }
         .badge[data-badge="streak_master"] { background-color: var(--danger-color); }


        /* --- Modal --- */
        .modal {
             display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); animation: fadeInModal 0.3s;
         }
         .modal-content {
             background-color: var(--card-bg); margin: 10% auto; padding: 30px; border: 1px solid var(--border-color); width: 80%; max-width: 600px; border-radius: 8px; box-shadow: var(--shadow);
         }
         .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
         .close-btn:hover, .close-btn:focus { color: var(--danger-color); text-decoration: none; }
         @keyframes fadeInModal { from { opacity: 0 } to { opacity: 1 } }


        /* --- Pomodoro Timer --- */
        #timer-display { font-size: 3em; font-weight: bold; color: var(--primary-color); text-align: center; margin-bottom: 1rem; }
        #timer-controls { text-align: center; display: flex; gap: 10px; justify-content: center; }


        /* --- Review Section --- */
        .review-checklist li { display: flex; align-items: center; margin-bottom: 0.8rem; }
        .review-checklist input[type="checkbox"] { margin-right: 10px; transform: scale(1.2); }

        /* --- Footer --- */
        footer { text-align: center; padding: 1rem; margin-top: 2rem; color: #777; font-size: 0.9em; border-top: 1px solid var(--border-color); }
         body.dark-theme footer { color: #aaa; }


        /* --- Responsive (Basic) --- */
        @media (max-width: 768px) {
            .container { flex-direction: column; }
            nav#sidebar { width: 100%; border-right: none; border-bottom: 1px solid var(--border-color); flex-direction: row; justify-content: space-around; padding: 0.5rem 0; align-items: center;}
            nav#sidebar ul { display: flex; flex-wrap: wrap; width: auto; margin-bottom: 0; justify-content: center;}
            nav#sidebar li a { padding: 0.5rem; margin-bottom: 0; text-align: center; }
             #theme-toggle { margin-top: 0; } /* Adjust theme toggle position */
            header { flex-direction: column; align-items: flex-start; }
             .header-right { margin-top: 10px; width: 100%; justify-content: space-between;}
             main#content { padding: 1rem; }
             .input-group { padding: 1rem; }
             .modal-content { width: 95%; margin: 15% auto; }
        }

    </style>
</head>
<body>

    <header>
        <h1>NexusFlow</h1>
        <div class="header-right">
             <div class="gamification-status">
                 <span>Points: <span id="points-display">0</span></span>
                 <span>Level: <span id="level-display">1</span></span>
            </div>
            <!-- Theme toggle moved to sidebar for better mobile layout -->
        </div>
    </header>

    <div class="container">
        <nav id="sidebar">
            <ul>
                <li><a href="#" class="nav-link active" data-view="goals-view">Goals & Tasks</a></li>
                <li><a href="#" class="nav-link" data-view="inbox-view">Inbox</a></li>
                <li><a href="#" class="nav-link" data-view="today-focus-view">Today's Focus</a></li>
                <li><a href="#" class="nav-link" data-view="calendar-view">Calendar</a></li>
                <li><a href="#" class="nav-link" data-view="habits-view">Habits</a></li>
                <li><a href="#" class="nav-link" data-view="notes-view">Notes</a></li>
                 <li><a href="#" class="nav-link" data-view="timer-view">Timer</a></li>
                 <li><a href="#" class="nav-link" data-view="reviews-view">Reviews</a></li>
            </ul>
            <button id="theme-toggle">Toggle Theme</button>
        </nav>

        <main id="content">
            <!-- Goals & Tasks View -->
            <section id="goals-view" class="view active">
                <h2>Goals & Tasks</h2>

                <div class="input-group">
                    <form id="add-item-form">
                         <label for="item-type">Type:</label>
                         <select id="item-type" name="item-type" required>
                              <option value="yearly">Yearly Goal</option>
                              <option value="monthly">Monthly Goal</option>
                              <option value="weekly">Weekly Goal</option>
                              <option value="daily">Daily Task</option>
                         </select>

                         <label for="item-parent">Parent Goal:</label>
                         <select id="item-parent" name="item-parent">
                              <option value="">-- Select Parent --</option>
                         </select>

                         <label for="item-title">Title:</label>
                         <input type="text" id="item-title" name="item-title" placeholder="Enter goal or task title" required>

                         <label for="item-date">Due Date (Optional):</label>
                         <input type="date" id="item-date" name="item-date">

                         <label for="item-context">Context (Optional):</label>
                          <select id="item-context" name="item-context">
                              <option value="">-- Select Context --</option>
                              <!-- Populated by JS -->
                          </select>

                         <label for="item-notes">Notes (Optional):</label>
                         <textarea id="item-notes" name="item-notes" placeholder="Add details..."></textarea>


                         <button type="submit" class="btn">Add Item</button>
                    </form>
                </div>

                 <!-- Display Area for Goals and Tasks -->
                 <div id="goals-tasks-display">
                     <!-- JS will populate this recursively -->
                 </div>

                 <!-- Gamification Visuals Section -->
                 <section id="gamification-visuals">
                     <h3>Your Progress</h3>
                     <div id="plant-container">
                         <div id="plant-stem"></div>
                         <div id="plant-leaf"></div>
                     </div>
                     <p>Level: <span id="plant-level-display">1</span></p>
                     <div id="badge-container">
                         <!-- Badges populated by JS -->
                     </div>
                 </section>
            </section>

            <!-- Inbox View -->
            <section id="inbox-view" class="view">
                <h2>GTD Inbox (<span id="inbox-count">0</span>)</h2>
                <p>Capture everything here. Process items into actionable tasks or goals.</p>
                 <div class="input-group">
                     <form id="add-inbox-form">
                          <label for="inbox-item-text">Capture Idea/Task:</label>
                          <input type="text" id="inbox-item-text" name="inbox-item-text" placeholder="Quick capture..." required>
                          <button type="submit" class="btn">Add to Inbox</button>
                     </form>
                 </div>
                <ul id="inbox-list" class="item-list"></ul>
            </section>

            <!-- Today's Focus View -->
            <section id="today-focus-view" class="view">
                <h2>Today's Focus</h2>
                <p>Actionable tasks prioritized for today.</p>
                <ul id="today-tasks-list" class="item-list"></ul>
            </section>

            <!-- Calendar View -->
            <section id="calendar-view" class="view">
                <h2>Calendar</h2>
                 <div id="calendar-container">
                     <div id="calendar-header">
                         <button id="prev-month">&lt; Prev</button>
                         <span id="month-year">Month Year</span>
                         <button id="next-month">Next &gt;</button>
                     </div>
                     <table id="calendar-grid">
                         <thead><tr><th>Sun</th><th>Mon</th><th>Tue</th><th>Wed</th><th>Thu</th><th>Fri</th><th>Sat</th></tr></thead>
                         <tbody><!-- Populated by JS --></tbody>
                     </table>
                 </div>
                 <div id="calendar-task-list" style="margin-top: 1rem;">
                     <!-- Display tasks for selected date - Maybe later -->
                 </div>
            </section>

             <!-- Habits View -->
            <section id="habits-view" class="view">
                <h2>Habit Tracker</h2>
                 <div class="input-group">
                    <form id="add-habit-form">
                         <label for="habit-title">New Habit:</label>
                         <input type="text" id="habit-title" placeholder="e.g., Drink 8 glasses of water" required>
                         <label for="habit-frequency">Frequency:</label>
                         <select id="habit-frequency">
                             <option value="daily">Daily</option>
                             <option value="weekly">Weekly</option>
                         </select>
                          <label for="habit-goal-link">Link to Goal (Optional):</label>
                         <select id="habit-goal-link">
                              <option value="">-- None --</option>
                         </select>
                         <button type="submit" class="btn">Add Habit</button>
                    </form>
                </div>
                <ul id="habits-list" class="item-list"></ul>
            </section>

            <!-- Notes View -->
            <section id="notes-view" class="view">
                <h2>Notes</h2>
                 <div class="input-group">
                     <form id="add-note-form">
                         <label for="note-title">Note Title:</label>
                         <input type="text" id="note-title" placeholder="Title for your note" required>
                         <label for="note-content">Content:</label>
                         <textarea id="note-content" required></textarea>
                          <label for="note-link">Link to Goal/Task (Optional):</label>
                         <select id="note-link">
                              <option value="">-- Standalone Note --</option>
                         </select>
                         <button type="submit" class="btn">Save Note</button>
                     </form>
                 </div>
                 <ul id="notes-list" class="item-list"></ul>
            </section>

             <!-- Timer View -->
            <section id="timer-view" class="view">
                 <h2>Pomodoro Timer</h2>
                  <div class="input-group" style="text-align: center;">
                     <div id="timer-display">25:00</div>
                     <div id="timer-controls">
                         <button id="start-timer" class="btn">Start</button>
                         <button id="pause-timer" class="btn" style="background-color: var(--warning-color);">Pause</button>
                         <button id="reset-timer" class="btn" style="background-color: var(--danger-color);">Reset</button>
                     </div>
                  </div>
             </section>

             <!-- Reviews View -->
            <section id="reviews-view" class="view">
                <h2>Weekly/Monthly Review</h2>
                <p>Take time to reflect and plan based on GTD principles.</p>
                <div class="input-group">
                    <ul class="review-checklist">
                        <li><input type="checkbox" id="review-inbox"> <label for="review-inbox">Process your Inbox completely.</label></li>
                        <li><input type="checkbox" id="review-goals"> <label for="review-goals">Review Yearly, Monthly, and Weekly Goals. Adjust as needed.</label></li>
                         <li><input type="checkbox" id="review-projects"> <label for="review-projects">Review active Projects/Goals list. Ensure next actions are defined.</label></li>
                        <li><input type="checkbox" id="review-calendar"> <label for="review-calendar">Review past and upcoming calendar entries.</label></li>
                         <li><input type="checkbox" id="review-waiting"> <label for="review-waiting">Review your "Waiting For" list (if implemented).</label></li>
                         <li><input type="checkbox" id="review-someday"> <label for="review-someday">Review "Someday/Maybe" list (if implemented).</label></li>
                         <li><input type="checkbox" id="review-habits"> <label for="review-habits">Review Habit progress.</label></li>
                    </ul>
                    <button id="mark-review-done" class="btn">Mark Review as Completed</button>
                    <p style="margin-top: 10px; font-size: 0.9em;">Last review completed: <span id="last-review-date">Never</span></p>
                </div>
            </section>

        </main>
    </div>

     <!-- Process Inbox Item Modal -->
     <div id="process-modal" class="modal">
        <div class="modal-content">
             <span class="close-btn" onclick="closeModal()">&times;</span>
            <h2>Process Inbox Item</h2>
            <form id="process-inbox-form">
                <input type="hidden" id="process-inbox-id">
                 <label for="process-item-type">Convert To:</label>
                 <select id="process-item-type" name="process-item-type" required>
                      <option value="daily">Daily Task</option>
                      <option value="weekly">Weekly Goal</option>
                      <option value="monthly">Monthly Goal</option>
                      <option value="yearly">Yearly Goal</option>
                      <!-- Maybe 'Note' or 'Habit' options later -->
                 </select>

                 <label for="process-item-parent">Parent Goal:</label>
                 <select id="process-item-parent" name="process-item-parent">
                      <option value="">-- Select Parent --</option>
                 </select>

                 <label for="process-item-title">Title:</label>
                 <input type="text" id="process-item-title" name="process-item-title" required>

                 <label for="process-item-date">Due Date (Optional):</label>
                 <input type="date" id="process-item-date" name="process-item-date">

                 <label for="process-item-context">Context (Optional):</label>
                  <select id="process-item-context" name="process-item-context">
                      <option value="">-- Select Context --</option>
                      <!-- Populated by JS -->
                  </select>

                 <label for="process-item-notes">Notes (Optional):</label>
                 <textarea id="process-item-notes" name="process-item-notes"></textarea>

                <button type="submit" class="btn">Process Item</button>
            </form>
        </div>
     </div>

    <footer>
        NexusFlow Enhanced Prototype - Single File Demo
        <p style="font-size: 0.8em; color: #999;">Note: Drag&Drop, External Sync, advanced features omitted due to single-file constraint.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Get Elements ---
            const views = document.querySelectorAll('.view');
            const navLinks = document.querySelectorAll('.nav-link');
            const themeToggle = document.getElementById('theme-toggle');

            // Goals & Tasks
            const addItemForm = document.getElementById('add-item-form');
            const itemTypeSelect = document.getElementById('item-type');
            const itemParentSelect = document.getElementById('item-parent');
            const itemTitleInput = document.getElementById('item-title');
            const itemDateInput = document.getElementById('item-date');
            const itemContextSelect = document.getElementById('item-context');
            const itemNotesTextarea = document.getElementById('item-notes');
            const goalsTasksDisplay = document.getElementById('goals-tasks-display');

            // Inbox
            const addInboxForm = document.getElementById('add-inbox-form');
            const inboxItemInput = document.getElementById('inbox-item-text');
            const inboxList = document.getElementById('inbox-list');
            const inboxCountSpan = document.getElementById('inbox-count');
            const processModal = document.getElementById('process-modal');
            const processInboxForm = document.getElementById('process-inbox-form');
            const processInboxIdInput = document.getElementById('process-inbox-id');

            // Today Focus
            const todayTasksList = document.getElementById('today-tasks-list');

            // Calendar
            const calendarGridBody = document.querySelector('#calendar-grid tbody');
            const monthYearDisplay = document.getElementById('month-year');
            const prevMonthBtn = document.getElementById('prev-month');
            const nextMonthBtn = document.getElementById('next-month');

             // Habits
             const addHabitForm = document.getElementById('add-habit-form');
             const habitTitleInput = document.getElementById('habit-title');
             const habitFrequencySelect = document.getElementById('habit-frequency');
             const habitGoalLinkSelect = document.getElementById('habit-goal-link');
             const habitsList = document.getElementById('habits-list');

             // Notes
             const addNoteForm = document.getElementById('add-note-form');
             const noteTitleInput = document.getElementById('note-title');
             const noteContentTextarea = document.getElementById('note-content');
             const noteLinkSelect = document.getElementById('note-link');
             const notesList = document.getElementById('notes-list');

             // Timer
             const timerDisplay = document.getElementById('timer-display');
             const startTimerBtn = document.getElementById('start-timer');
             const pauseTimerBtn = document.getElementById('pause-timer');
             const resetTimerBtn = document.getElementById('reset-timer');

              // Reviews
             const markReviewDoneBtn = document.getElementById('mark-review-done');
             const lastReviewDateSpan = document.getElementById('last-review-date');
             const reviewChecklistItems = document.querySelectorAll('.review-checklist input[type="checkbox"]');

            // Gamification
            const pointsDisplay = document.getElementById('points-display');
            const levelDisplay = document.getElementById('level-display');
            const plantStem = document.getElementById('plant-stem');
            const plantLeaf = document.getElementById('plant-leaf');
            const plantLevelDisplay = document.getElementById('plant-level-display');
             const badgeContainer = document.getElementById('badge-container');

            // --- State & Data ---
            let data = {
                goals: [], // { id, type, title, parentId, children: [], date, context, notes, created }
                tasks: [], // { id, type: 'daily', title, parentId, completed: false, date, context, notes, created, completedDate }
                inbox: [], // { id, text, created }
                habits: [], // { id, title, frequency: 'daily'/'weekly', goalId: null, completedDates: [], streak: 0, created }
                notes: [], // { id, title, content, linkedItemId: null, linkedItemType: null, created }
                gamification: {
                    points: 0,
                    level: 1,
                    badges: [] // e.g., 'visionary', 'inbox_zero', 'first_task', 'streak_master_5'
                },
                settings: {
                    theme: 'light',
                    contexts: ["@home", "@work", "@computer", "@errands", "@calls", "@waiting"]
                },
                 lastReviewDate: null, // Store as ISO string
                currentCalendarDate: new Date() // For calendar view
            };

            let timerInterval = null;
            let timerSeconds = 25 * 60; // Default Pomodoro time
            let timerRunning = false;

            const POINTS_PER_TASK = 10;
            const POINTS_PER_HABIT = 5;
            const POINTS_PER_REVIEW = 25;
            const POINTS_PER_LEVEL = 100; // Points needed to level up

            const BADGES = {
                'visionary': { name: "Visionary", description: "Set your first Yearly Goal", achieved: false },
                'first_task': { name: "First Step", description: "Complete your first Daily Task", achieved: false },
                'inbox_zero': { name: "Inbox Zero Hero", description: "Clear your Inbox", achieved: false },
                'streak_master_5': { name: "Habit Starter", description: "Achieve a 5-day habit streak", achieved: false },
                'goal_getter_w': { name: "Weekly Winner", description: "Complete all tasks linked to a Weekly Goal", achieved: false } // More complex to check
            };


            // --- Utility Functions ---
            const generateId = () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const todayISO = () => new Date().toISOString().split('T')[0];
            const formatItemDate = (isoDate) => isoDate ? new Date(isoDate).toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) : 'No date';

            const saveData = () => {
                 try {
                    localStorage.setItem('nexusFlowData_v2', JSON.stringify(data));
                 } catch (e) {
                     console.error("Error saving data to localStorage:", e);
                     alert("Error saving data. LocalStorage might be full.");
                 }
            };

            const loadData = () => {
                const savedData = localStorage.getItem('nexusFlowData_v2');
                 let loadedCorrectly = false;
                 if (savedData) {
                     try {
                        data = JSON.parse(savedData);
                         // --- Data Migration/Defaults ---
                         data.goals = data.goals || [];
                         data.tasks = data.tasks || [];
                         data.inbox = data.inbox || [];
                         data.habits = data.habits || [];
                         data.notes = data.notes || [];
                         data.gamification = data.gamification || { points: 0, level: 1, badges: [] };
                         data.gamification.badges = data.gamification.badges || [];
                         data.settings = data.settings || { theme: 'light', contexts: ["@home", "@work", "@computer", "@errands", "@calls", "@waiting"] };
                         data.settings.contexts = data.settings.contexts || ["@home", "@work", "@computer", "@errands", "@calls", "@waiting"]; // Ensure contexts exist
                         data.lastReviewDate = data.lastReviewDate || null;
                         data.currentCalendarDate = new Date(data.currentCalendarDate) || new Date();
                          // Add potentially missing fields to existing items
                          data.goals.forEach(g => { g.children = g.children || []; g.notes = g.notes || ''; });
                          data.tasks.forEach(t => { t.notes = t.notes || ''; t.type = 'daily';}); // Ensure type=daily for tasks
                           data.habits.forEach(h => { h.completedDates = h.completedDates || []; });
                           loadedCorrectly = true;
                     } catch (e) {
                         console.error("Error parsing saved data:", e);
                         alert("Could not load saved data. It might be corrupted. Starting fresh.");
                         localStorage.removeItem('nexusFlowData_v2'); // Clear corrupted data
                          // Reinitialize data object if parse failed
                         data = { /* Re-initialize structure */ };
                     }
                 }

                // Initialize calendar date if not loaded
                 if (!data.currentCalendarDate || isNaN(data.currentCalendarDate.getTime())) {
                     data.currentCalendarDate = new Date();
                 }

                // Apply theme
                 applyTheme(data.settings.theme);
                 // Ensure base level calculation on load
                 updateLevel();
                 updateBadgeDataStructure(); // Sync BADGES state with saved data
             };


            // --- Rendering Functions ---

            // Renders Goals and Tasks Recursively
            const renderGoalsAndTasks = () => {
                goalsTasksDisplay.innerHTML = ''; // Clear current display

                const createItemElement = (item) => {
                    const li = document.createElement('li');
                    li.classList.add(item.type === 'daily' ? 'daily-task' : `${item.type}-goal`, 'item'); // Added 'item' class for potential future selectors
                     li.dataset.id = item.id;
                    li.dataset.type = item.type; // Store type

                    let childrenHTML = '';
                    if (item.children && item.children.length > 0) {
                        childrenHTML += '<ul class="item-list">';
                         item.children.forEach(childId => {
                             const childGoal = data.goals.find(g => g.id === childId);
                             if (childGoal) {
                                 const childElement = createItemElement(childGoal); // Recursive call for sub-goals
                                 childrenHTML += childElement.outerHTML; // Add child HTML
                             }
                         });
                         // Render tasks associated directly with this goal
                         const relatedTasks = data.tasks.filter(t => t.parentId === item.id);
                         relatedTasks.forEach(task => {
                             const taskElement = createItemElement(task); // Recursive call for tasks
                             childrenHTML += taskElement.outerHTML;
                         });
                         childrenHTML += '</ul>';
                    } else if (item.type !== 'daily') {
                         // Also render tasks for goals that don't have sub-goals
                         const relatedTasks = data.tasks.filter(t => t.parentId === item.id);
                         if (relatedTasks.length > 0) {
                             childrenHTML += '<ul class="item-list">';
                             relatedTasks.forEach(task => {
                                 const taskElement = createItemElement(task);
                                 childrenHTML += taskElement.outerHTML;
                             });
                             childrenHTML += '</ul>';
                         }
                     }

                    const details = [];
                    if (item.date) details.push(`📅 ${formatItemDate(item.date)}`);
                    if (item.context) details.push(`🏷️ ${item.context}`);

                    let headerHTML = `
                         <div class="item-header">
                            ${item.type === 'daily' ? `<input type="checkbox" class="task-checkbox" ${item.completed ? 'checked' : ''}>` : ''}
                             <span class="item-title">${item.title}</span>
                             <div class="item-actions">
                                 <button class="btn btn-delete btn-small">Del</button>
                                 <!-- Add Edit button later -->
                             </div>
                        </div>
                        ${details.length > 0 ? `<div class="item-details">${details.map(d => `<span>${d}</span>`).join('')}</div>` : ''}
                         ${item.notes ? `<div class="item-note">📝 ${item.notes}</div>` : ''}
                     `;

                    li.innerHTML = headerHTML + childrenHTML;

                    if (item.type === 'daily' && item.completed) {
                        li.classList.add('completed');
                    }

                    return li; // Return the element itself for outerHTML usage
                };

                 // Start rendering from top-level (yearly) goals
                 const yearlyGoals = data.goals.filter(g => g.type === 'yearly' && !g.parentId); // Ensure only true top level
                 yearlyGoals.forEach(goal => {
                     goalsTasksDisplay.appendChild(createItemElement(goal));
                 });
                // Render top-level daily tasks (not linked to goals) - SHOULD BE DISCOURAGED by logic
                // const orphanedTasks = data.tasks.filter(t => !t.parentId);
                // orphanedTasks.forEach(task => {
                //     goalsTasksDisplay.appendChild(createItemElement(task));
                // });


                 // Add event listeners AFTER appending to DOM
                 goalsTasksDisplay.querySelectorAll('.btn-delete').forEach(btn => {
                    const li = btn.closest('li');
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                         if(li && li.dataset.id && li.dataset.type) {
                            deleteItem(li.dataset.id, li.dataset.type);
                         } else {
                             console.error("Could not find item ID or type for deletion.");
                         }
                    });
                 });
                 goalsTasksDisplay.querySelectorAll('.task-checkbox').forEach(checkbox => {
                    const li = checkbox.closest('li');
                    checkbox.addEventListener('change', (e) => {
                        if (li && li.dataset.id) {
                             toggleTaskComplete(li.dataset.id);
                         } else {
                            console.error("Could not find task ID for completion toggle.");
                        }
                    });
                });


                // Update dropdowns that depend on goals/tasks
                 updateParentSelect();
                updateLinkToSelects(); // For habits/notes linking
                 renderTodayFocus(); // Update today view too
            };

             const renderInbox = () => {
                 inboxList.innerHTML = '';
                 let count = 0;
                 data.inbox.forEach(item => {
                     count++;
                     const li = document.createElement('li');
                     li.classList.add('inbox-item', 'item');
                     li.dataset.id = item.id;
                     li.innerHTML = `
                         <div class="item-header">
                             <span class="item-title">${item.text}</span>
                             <div class="item-actions">
                                 <button class="btn btn-process btn-small">Process</button>
                                 <button class="btn btn-delete btn-small">Del</button>
                             </div>
                         </div>
                         <div class="item-details"><span>Captured: ${new Date(item.created).toLocaleString()}</span></div>
                     `;
                     li.querySelector('.btn-delete').addEventListener('click', () => deleteItem(item.id, 'inbox'));
                     li.querySelector('.btn-process').addEventListener('click', () => openProcessModal(item.id));
                     inboxList.appendChild(li);
                 });
                 inboxCountSpan.textContent = count;
                  // Check for inbox zero badge
                 if (count === 0 && data.inbox.length === 0 && !BADGES['inbox_zero'].achieved) {
                     awardBadge('inbox_zero');
                 }
             };

             const renderTodayFocus = () => {
                todayTasksList.innerHTML = '';
                const todayStr = todayISO();
                 // Prioritize tasks due today, then show other incomplete tasks
                const dueToday = data.tasks.filter(task => !task.completed && task.date === todayStr);
                const otherIncomplete = data.tasks.filter(task => !task.completed && task.date !== todayStr);

                if (dueToday.length === 0 && otherIncomplete.length === 0) {
                    todayTasksList.innerHTML = '<li style="border: none; box-shadow: none; text-align: center; color: #888;">No actionable tasks right now. Well done!</li>';
                    return;
                }

                const renderTaskItem = (task) => {
                     const li = document.createElement('li');
                     li.classList.add('daily-task', 'item');
                     li.dataset.id = task.id;
                     if (task.completed) li.classList.add('completed');

                    const details = [];
                    if (task.date) details.push(`📅 ${formatItemDate(task.date)}`);
                    if (task.context) details.push(`🏷️ ${task.context}`);
                     const parentGoal = data.goals.find(g => g.id === task.parentId);
                     if(parentGoal) details.push(`🎯 ${parentGoal.title.substring(0, 20)}...`);

                     li.innerHTML = `
                        <div class="item-header">
                             <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''}>
                            <span class="item-title">${task.title}</span>
                             <div class="item-actions">
                                 <button class="btn btn-delete btn-small">Del</button>
                            </div>
                        </div>
                         ${details.length > 0 ? `<div class="item-details">${details.map(d => `<span>${d}</span>`).join('')}</div>` : ''}
                         ${task.notes ? `<div class="item-note">📝 ${task.notes}</div>` : ''}
                    `;
                     // Add listeners after innerHTML is set
                    li.querySelector('.task-checkbox').addEventListener('change', () => toggleTaskComplete(task.id));
                    li.querySelector('.btn-delete').addEventListener('click', () => deleteItem(task.id, 'daily'));
                    return li;
                 };

                 if (dueToday.length > 0) {
                    const heading = document.createElement('h4');
                    heading.textContent = "Due Today";
                    heading.style.marginTop = "0";
                    todayTasksList.appendChild(heading);
                    dueToday.forEach(task => todayTasksList.appendChild(renderTaskItem(task)));
                 }
                 if (otherIncomplete.length > 0) {
                     const heading = document.createElement('h4');
                     heading.textContent = "Other Tasks";
                     todayTasksList.appendChild(heading);
                     otherIncomplete.forEach(task => todayTasksList.appendChild(renderTaskItem(task)));
                 }
             };


            const renderCalendar = () => {
                 calendarGridBody.innerHTML = '';
                 const year = data.currentCalendarDate.getFullYear();
                 const month = data.currentCalendarDate.getMonth(); // 0-indexed

                 monthYearDisplay.textContent = `${data.currentCalendarDate.toLocaleString('default', { month: 'long' })} ${year}`;

                 const firstDayOfMonth = new Date(year, month, 1).getDay(); // 0=Sun, 1=Mon,...
                 const daysInMonth = new Date(year, month + 1, 0).getDate();

                 let date = 1;
                 let otherMonthDate = new Date(year, month, 0).getDate() - firstDayOfMonth + 1; // Start day for prev month cells

                 // Get tasks for the *current* visible month +- buffer days
                 const tasksWithDates = data.tasks.filter(t => t.date);
                 const tasksThisMonth = tasksWithDates.filter(t => {
                     const taskDate = new Date(t.date + 'T00:00:00'); // Ensure date parsing is local
                     return taskDate.getFullYear() === year && taskDate.getMonth() === month;
                 });

                 for (let i = 0; i < 6; i++) { // Max 6 rows
                     const row = document.createElement('tr');
                     let rowHasDates = false; // Optimization: stop if no more dates

                     for (let j = 0; j < 7; j++) { // 7 days
                         const cell = document.createElement('td');
                         if (i === 0 && j < firstDayOfMonth) {
                              // Previous month's days
                             cell.classList.add('other-month');
                             // cell.textContent = otherMonthDate++; // Optionally display prev month dates
                         } else if (date > daysInMonth) {
                             // Next month's days
                              cell.classList.add('other-month');
                              // Optionally display next month dates
                         } else {
                              // Current month's days
                              rowHasDates = true;
                             cell.textContent = date;
                             const currentDateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(date).padStart(2, '0')}`;

                             // Check if today
                              if (date === new Date().getDate() && month === new Date().getMonth() && year === new Date().getFullYear()) {
                                 cell.classList.add('today');
                             }

                             // Check for tasks on this date
                              const tasksOnDate = tasksThisMonth.filter(t => t.date === currentDateStr);
                              if (tasksOnDate.length > 0) {
                                  const indicator = document.createElement('span');
                                  indicator.classList.add('calendar-task-indicator');
                                  indicator.title = `${tasksOnDate.length} task(s)`;
                                  cell.appendChild(indicator);
                                  // Maybe add click listener here later
                             }
                             date++;
                         }
                         row.appendChild(cell);
                     }
                      if (!rowHasDates && i > 0) break; // Don't add empty trailing rows
                      calendarGridBody.appendChild(row);
                  }
              };


            const renderHabits = () => {
                 habitsList.innerHTML = '';
                 const today = todayISO();
                 const currentDayOfWeek = new Date().getDay(); // 0=Sun, 6=Sat

                 data.habits.forEach(habit => {
                     const li = document.createElement('li');
                     li.classList.add('habit-item', 'item');
                     li.dataset.id = habit.id;

                     let isCompletedToday = false;
                     if (habit.frequency === 'daily') {
                         isCompletedToday = habit.completedDates.includes(today);
                     } else if (habit.frequency === 'weekly') {
                         // Check if completed *any* day since the last Sunday
                          const todayDate = new Date(today);
                          const sundayDate = new Date(todayDate);
                          sundayDate.setDate(todayDate.getDate() - currentDayOfWeek);
                          const sundayISO = sundayDate.toISOString().split('T')[0];
                          isCompletedToday = habit.completedDates.some(d => d >= sundayISO && d <= today);
                      }

                     const goalLinkText = habit.goalId ? `🎯 Linked: ${data.goals.find(g=>g.id === habit.goalId)?.title.substring(0,20) || 'N/A'}...` : '';

                     li.innerHTML = `
                         <div class="item-header">
                             <input type="checkbox" class="habit-checkbox" ${isCompletedToday ? 'checked' : ''}>
                            <span class="item-title">${habit.title} (${habit.frequency})</span>
                             <div class="item-actions">
                                <span class="badge" style="background-color: var(--accent-color); margin-right: 10px;">Streak: ${habit.streak || 0}</span>
                                <button class="btn btn-delete btn-small">Del</button>
                            </div>
                        </div>
                         <div class="item-details"><span>${goalLinkText}</span></div>
                     `;
                     li.querySelector('.habit-checkbox').addEventListener('change', (e) => toggleHabitComplete(habit.id, e.target.checked));
                     li.querySelector('.btn-delete').addEventListener('click', () => deleteItem(habit.id, 'habit'));
                     habitsList.appendChild(li);
                 });
             };

            const renderNotes = () => {
                 notesList.innerHTML = '';
                 data.notes.forEach(note => {
                     const li = document.createElement('li');
                     li.classList.add('note-item', 'item');
                     li.dataset.id = note.id;

                      let linkText = 'Standalone';
                      if(note.linkedItemId && note.linkedItemType) {
                          const linkedItem = note.linkedItemType === 'daily'
                              ? data.tasks.find(i => i.id === note.linkedItemId)
                              : data.goals.find(i => i.id === note.linkedItemId);
                          if(linkedItem) linkText = `🔗 ${linkedItem.title.substring(0, 30)}... (${note.linkedItemType})`;
                          else linkText = '🔗 Link Broken';
                      }


                     li.innerHTML = `
                         <div class="item-header">
                            <span class="item-title">${note.title}</span>
                             <div class="item-actions">
                                <button class="btn btn-delete btn-small">Del</button>
                            </div>
                         </div>
                         <div class="note-content" style="margin-top: 5px; white-space: pre-wrap;">${note.content}</div>
                         <div class="item-details" style="margin-top: 10px;">
                             <span>${linkText}</span>
                              <span>Created: ${new Date(note.created).toLocaleDateString()}</span>
                         </div>
                     `;
                      // Add edit listener later if needed
                      li.querySelector('.btn-delete').addEventListener('click', () => deleteItem(note.id, 'note'));
                     notesList.appendChild(li);
                 });
            };


             const renderGamificationVisuals = () => {
                 // Plant Growth
                 const maxLevel = 10; // Arbitrary max level for visual scaling
                 const normalizedLevel = Math.min(data.gamification.level, maxLevel);
                 const stemHeight = (normalizedLevel / maxLevel) * 100; // Percentage of max stem height (e.g., 100px)
                 const leafOpacity = normalizedLevel > 2 ? 1 : 0; // Show leaf after level 2
                 const leafSize = 10 + (normalizedLevel * 1.5); // Leaf size increases
                 const leafRotation = (normalizedLevel % 5) * 15; // Simple rotation

                 plantStem.style.height = `${stemHeight}%`;
                 if (normalizedLevel > 1) { // Only show leaf if level > 1
                     plantLeaf.style.opacity = '1';
                     plantLeaf.style.borderLeftWidth = `${leafSize / 2}px`;
                     plantLeaf.style.borderRightWidth = `${leafSize / 2}px`;
                     plantLeaf.style.borderBottomWidth = `${leafSize}px`;
                      plantLeaf.style.bottom = `${Math.min(stemHeight, 80)}%`; // Position relative to stem
                      plantLeaf.style.transform = `translateX(-50%) rotate(${leafRotation}deg)`;
                  } else {
                      plantLeaf.style.opacity = '0';
                  }


                  plantLevelDisplay.textContent = data.gamification.level;

                  // Badges
                  badgeContainer.innerHTML = '';
                   data.gamification.badges.forEach(badgeId => {
                       if (BADGES[badgeId]) {
                            const badgeEl = document.createElement('span');
                            badgeEl.classList.add('badge');
                            badgeEl.dataset.badge = badgeId;
                           badgeEl.textContent = BADGES[badgeId].name;
                           badgeEl.title = BADGES[badgeId].description;
                           badgeContainer.appendChild(badgeEl);
                       }
                   });
              };

              const renderReviewStatus = () => {
                   lastReviewDateSpan.textContent = data.lastReviewDate ? new Date(data.lastReviewDate).toLocaleDateString() : 'Never';
                   // Clear checkboxes
                   reviewChecklistItems.forEach(cb => cb.checked = false);
              };


             // --- Update Dropdowns ---
             const updateContextSelects = () => {
                const contexts = data.settings.contexts || [];
                const optionsHTML = '<option value="">-- Select Context --</option>' + contexts.map(c => `<option value="${c}">${c}</option>`).join('');
                itemContextSelect.innerHTML = optionsHTML;
                 // Also update the process modal context select
                document.getElementById('process-item-context').innerHTML = optionsHTML;
             };

            const updateParentSelect = (selectElement = itemParentSelect, currentItem = null) => {
                 selectElement.innerHTML = '<option value="">-- Select Parent --</option>'; // Reset

                const populateOptions = (potentialParents, prefix = '') => {
                     potentialParents.forEach(goal => {
                          // Prevent linking to self or children
                         if (currentItem && (goal.id === currentItem.id || isDescendant(currentItem, goal.id))) {
                              return;
                         }

                         const option = document.createElement('option');
                         option.value = goal.id;
                         option.textContent = `${prefix}${goal.title} (${goal.type})`;
                         // Pre-select if this was the item's original parent
                         if (currentItem && currentItem.parentId === goal.id) {
                              option.selected = true;
                         }
                         selectElement.appendChild(option);

                          // Recursively add children
                         const children = data.goals.filter(g => g.parentId === goal.id);
                          if (children.length > 0) {
                             populateOptions(children, prefix + '    ');
                          }
                     });
                 };

                 // Start with top-level goals only for the recursion root
                 const topLevelGoals = data.goals.filter(g => !g.parentId && g.type !== 'daily'); // Exclude daily tasks as parents
                 populateOptions(topLevelGoals);
             };

            // Helper to check if goal B is a descendant of goal A
            const isDescendant = (parentItem, childId) => {
                 if (!parentItem.children || parentItem.children.length === 0) {
                    return false;
                 }
                 if (parentItem.children.includes(childId)) {
                     return true;
                 }
                 // Check grandchildren recursively
                 for (const id of parentItem.children) {
                      const childGoal = data.goals.find(g => g.id === id);
                      if (childGoal && isDescendant(childGoal, childId)) {
                         return true;
                     }
                 }
                return false;
             };


             // Update selects in Habits and Notes forms to link items
             const updateLinkToSelects = () => {
                 const goalOptions = data.goals.map(g => `<option value="goal_${g.id}">${g.title} (Goal)</option>`).join('');
                 const taskOptions = data.tasks.map(t => `<option value="task_${t.id}">${t.title} (Task)</option>`).join('');

                 habitGoalLinkSelect.innerHTML = '<option value="">-- None --</option>' + goalOptions;
                  noteLinkSelect.innerHTML = '<option value="">-- Standalone Note --</option>' + goalOptions + taskOptions;
              };



            // --- Event Handlers ---
            const handleAddItemSubmit = (e) => {
                 e.preventDefault();
                 const type = itemTypeSelect.value;
                 const title = itemTitleInput.value.trim();
                 const parentId = itemParentSelect.value || null;
                 const date = itemDateInput.value || null;
                 const context = itemContextSelect.value || null;
                 const notes = itemNotesTextarea.value.trim();

                if (!title) return;

                 const newItem = {
                    id: generateId(),
                    type: type,
                    title: title,
                    parentId: parentId,
                    date: date,
                    context: context,
                    notes: notes,
                     created: new Date().toISOString()
                 };


                  // --- Hierarchy Validation ---
                  let validationPassed = true;
                  if (parentId) {
                      const parentGoal = data.goals.find(g => g.id === parentId);
                      if (!parentGoal) {
                          alert("Selected parent goal not found!");
                          validationPassed = false;
                       } else {
                           const hierarchy = { 'monthly': 'yearly', 'weekly': 'monthly', 'daily': ['yearly', 'monthly', 'weekly'] }; // Daily can be under Y/M/W
                           const allowedParentType = hierarchy[type];

                            if (type !== 'yearly' && !allowedParentType) {
                                alert(`Invalid item type selected: ${type}`);
                                validationPassed = false;
                            } else if (type === 'daily' && !Array.isArray(allowedParentType) && parentGoal.type !== allowedParentType) {
                                // This case shouldn't happen with current structure but good practice
                                alert(`A ${type} task must be under a Yearly, Monthly, or Weekly goal.`);
                                validationPassed = false;
                            } else if (type === 'daily' && Array.isArray(allowedParentType) && !allowedParentType.includes(parentGoal.type)) {
                                 alert(`A ${type} task must be under a Yearly, Monthly, or Weekly goal.`);
                                 validationPassed = false;
                            } else if (type !== 'daily' && !Array.isArray(allowedParentType) && parentGoal.type !== allowedParentType) {
                                 alert(`A ${type} goal must be under a ${allowedParentType} goal.`);
                                 validationPassed = false;
                            } else if (type === 'yearly') {
                                // Yearly goals cannot have parents in this structure
                                newItem.parentId = null;
                            }
                      }
                   } else if (type !== 'yearly') {
                      // Monthly, Weekly, Daily should ideally have parents
                      if (!confirm(`Add '${type}' item without linking to a parent? It's recommended to link items.`)) {
                          validationPassed = false;
                       }
                   }
                   //------------------------

                 if (!validationPassed) return; // Stop if validation failed

                 // Add to correct array
                 if (type === 'daily') {
                    newItem.completed = false;
                    data.tasks.push(newItem);
                 } else {
                     newItem.children = []; // Goals can have children
                    data.goals.push(newItem);
                      // Add to parent's children array IF parent exists and item is not yearly
                     if (parentId && type !== 'yearly') {
                         const parentGoal = data.goals.find(g => g.id === parentId);
                         if (parentGoal) { // Should always exist due to validation, but check again
                             parentGoal.children = parentGoal.children || [];
                             parentGoal.children.push(newItem.id);
                         }
                     }
                     // Award badge for first yearly goal
                     if (type === 'yearly' && !BADGES['visionary'].achieved) {
                         awardBadge('visionary');
                     }
                 }

                saveData();
                renderAll(); // Re-render relevant views
                addItemForm.reset(); // Clear form
                 updateParentSelect(); // Update parent list (new goal might be available)
                 updateLinkToSelects(); // Also update linking dropdowns
                 awardPoints(1); // Small points for adding items
            };


            const handleAddInboxSubmit = (e) => {
                 e.preventDefault();
                 const text = inboxItemInput.value.trim();
                 if (!text) return;
                 const newItem = { id: generateId(), text: text, created: new Date().toISOString() };
                 data.inbox.push(newItem);
                 saveData();
                 renderInbox();
                 inboxItemInput.value = '';
                  awardPoints(1); // Points for capture
             };

            const toggleTaskComplete = (taskId) => {
                const task = data.tasks.find(t => t.id === taskId);
                 if (!task) return;

                const previouslyCompleted = task.completed;
                task.completed = !task.completed;
                 task.completedDate = task.completed ? new Date().toISOString() : null;

                let pointsChange = 0;
                 if (task.completed && !previouslyCompleted) {
                     pointsChange = POINTS_PER_TASK;
                     showCompletionEffect(taskId);
                     // Award badge for first task completion
                      if (!BADGES['first_task'].achieved) {
                          awardBadge('first_task');
                      }
                      // Check if parent goal completed (basic check)
                      checkGoalCompletion(task.parentId);
                 } else if (!task.completed && previouslyCompleted) {
                     pointsChange = -POINTS_PER_TASK;
                 }

                awardPoints(pointsChange);
                saveData();
                renderGoalsAndTasks(); // Re-render needed to update style
                renderTodayFocus(); // Update Today view too
                // No need to update gamification display here, awardPoints does it
            };


            // Basic check if all direct child tasks of a goal are complete
            const checkGoalCompletion = (goalId) => {
                if (!goalId) return;
                const goal = data.goals.find(g => g.id === goalId);
                 if (!goal || goal.type === 'yearly') return; // Don't auto-complete yearly for now

                const childTasks = data.tasks.filter(t => t.parentId === goalId);
                if (childTasks.length > 0 && childTasks.every(t => t.completed)) {
                     // Potential: Award badge, show visual feedback, maybe auto-complete parent task if applicable
                    console.log(`All direct tasks for goal "${goal.title}" (${goalId}) are complete.`);
                     if (goal.type === 'weekly' && !BADGES['goal_getter_w'].achieved) {
                         // Check if THIS was the first time goal_getter_w achieved
                         // Need a more robust check here, perhaps storing goal completion status
                          awardBadge('goal_getter_w'); // Award tentatively
                      }
                     awardPoints(POINTS_PER_TASK * 2); // Bonus for completing goal scope
                     // TODO: Visually mark the goal as complete? (Needs new state in data.goals)
                 }
            };


            const showCompletionEffect = (itemId) => {
                const element = document.querySelector(`[data-id="${itemId}"]`);
                if (element) {
                    element.style.transition = 'background-color 0.1s ease-in-out';
                    element.style.backgroundColor = 'var(--accent-color)';
                    setTimeout(() => {
                        element.style.backgroundColor = ''; // Revert to original or completed style
                    }, 200);
                 }
             };


            // --- Deletion Logic ---
            const deleteItem = (itemId, itemType) => {
                 if (!confirm(`DELETE this ${itemType} and ALL its potential sub-items/links? This cannot be undone.`)) {
                     return;
                 }

                switch(itemType) {
                    case 'inbox':
                         data.inbox = data.inbox.filter(item => item.id !== itemId);
                        break;
                    case 'daily':
                        data.tasks = data.tasks.filter(task => task.id !== itemId);
                        // Also remove from any notes linked to it
                        data.notes.forEach(n => { if(n.linkedItemId === itemId) { n.linkedItemId = null; n.linkedItemType = null; } });
                        break;
                     case 'habit':
                         data.habits = data.habits.filter(habit => habit.id !== itemId);
                         break;
                     case 'note':
                         data.notes = data.notes.filter(note => note.id !== itemId);
                         break;
                    case 'yearly':
                    case 'monthly':
                    case 'weekly':
                        deleteGoalAndChildrenRecursive(itemId);
                         break;
                    default:
                         console.error("Unknown item type for deletion:", itemType);
                        return; // Don't save if type is unknown
                }

                saveData();
                renderAll(); // Re-render everything as deletion can have wide impact
                 updateParentSelect(); // Crucial after deleting potential parents
                 updateLinkToSelects();
             };


             const deleteGoalAndChildrenRecursive = (goalId) => {
                // 1. Find the goal
                 const goalIndex = data.goals.findIndex(g => g.id === goalId);
                 if (goalIndex === -1) return; // Goal already deleted or doesn't exist
                 const goal = data.goals[goalIndex];

                 // 2. Recursively delete all children goals FIRST
                 if (goal.children && goal.children.length > 0) {
                     // Iterate over a copy because the array might be modified during recursion
                     [...goal.children].forEach(childId => {
                         // Find if the child is a goal or task
                         if(data.goals.some(g => g.id === childId)) {
                              deleteGoalAndChildrenRecursive(childId);
                          } else if (data.tasks.some(t => t.id === childId)) {
                              // Although tasks shouldn't be in goal children, handle defensively
                              data.tasks = data.tasks.filter(t => t.id !== childId);
                         }
                    });
                 }

                 // 3. Delete all tasks directly linked to *this* goal
                 data.tasks = data.tasks.filter(task => task.parentId !== goalId);

                 // 4. Unlink any habits or notes linked to this goal
                  data.habits.forEach(h => { if(h.goalId === goalId) h.goalId = null; });
                 data.notes.forEach(n => { if(n.linkedItemId === goalId) { n.linkedItemId = null; n.linkedItemType = null; } });


                 // 5. Remove this goal from its parent's children array (if applicable)
                 if (goal.parentId) {
                     const parentGoal = data.goals.find(g => g.id === goal.parentId);
                     if (parentGoal && parentGoal.children) {
                         parentGoal.children = parentGoal.children.filter(id => id !== goalId);
                     }
                 }

                 // 6. Finally, delete the goal itself
                 data.goals.splice(goalIndex, 1);
              };



            // --- GTD Inbox Processing ---
            const openProcessModal = (inboxId) => {
                const item = data.inbox.find(i => i.id === inboxId);
                 if (!item) return;

                processInboxIdInput.value = inboxId;
                 // Pre-fill form fields
                document.getElementById('process-item-title').value = item.text;
                document.getElementById('process-item-type').value = 'daily'; // Default to task
                 updateParentSelect(document.getElementById('process-item-parent')); // Update parent options in modal
                 document.getElementById('process-item-date').value = '';
                 document.getElementById('process-item-context').value = '';
                 document.getElementById('process-item-notes').value = '';

                 processModal.style.display = 'block';
            };

            window.closeModal = () => { // Make globally accessible for onclick
                processModal.style.display = 'none';
             };

             // Close modal if clicking outside content
            window.onclick = (event) => {
                if (event.target == processModal) {
                    closeModal();
                }
            };


             processInboxForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const inboxId = processInboxIdInput.value;
                 const type = document.getElementById('process-item-type').value;
                 const title = document.getElementById('process-item-title').value.trim();
                 const parentId = document.getElementById('process-item-parent').value || null;
                 const date = document.getElementById('process-item-date').value || null;
                 const context = document.getElementById('process-item-context').value || null;
                 const notes = document.getElementById('process-item-notes').value.trim();

                if (!title || !inboxId) return;

                const newItem = {
                    id: generateId(), // Generate NEW id
                    type: type,
                    title: title,
                    parentId: parentId,
                    date: date,
                    context: context,
                    notes: notes,
                    created: new Date().toISOString()
                };

                // Add to correct array (logic similar to handleAddItemSubmit)
                let validationPassed = true; // Add similar validation as handleAddItemSubmit if needed
                // Simplified validation for brevity here
                 if (!validationPassed) return;

                if (type === 'daily') {
                    newItem.completed = false;
                    data.tasks.push(newItem);
                } else {
                    newItem.children = [];
                    data.goals.push(newItem);
                    if (parentId && type !== 'yearly') { // Link child if parent exists
                        const parentGoal = data.goals.find(g => g.id === parentId);
                         if(parentGoal) {
                            parentGoal.children = parentGoal.children || [];
                            parentGoal.children.push(newItem.id);
                         }
                     }
                    if (type === 'yearly' && !BADGES['visionary'].achieved) awardBadge('visionary');
                 }

                 // Delete original inbox item
                 data.inbox = data.inbox.filter(item => item.id !== inboxId);

                 saveData();
                 renderAll();
                 closeModal();
                  awardPoints(5); // Points for processing
            });



            // --- Calendar Navigation ---
            prevMonthBtn.addEventListener('click', () => {
                 data.currentCalendarDate.setMonth(data.currentCalendarDate.getMonth() - 1);
                 renderCalendar();
                 saveData(); // Save the new current month
            });
            nextMonthBtn.addEventListener('click', () => {
                data.currentCalendarDate.setMonth(data.currentCalendarDate.getMonth() + 1);
                renderCalendar();
                saveData(); // Save the new current month
            });


            // --- Habit Handling ---
            addHabitForm.addEventListener('submit', (e) => {
                 e.preventDefault();
                 const title = habitTitleInput.value.trim();
                 const frequency = habitFrequencySelect.value;
                 const goalId = habitGoalLinkSelect.value || null;
                 if (!title) return;

                 const newHabit = {
                     id: generateId(),
                     title: title,
                     frequency: frequency,
                     goalId: goalId,
                     completedDates: [],
                     streak: 0,
                     created: new Date().toISOString()
                 };
                 data.habits.push(newHabit);
                 saveData();
                 renderHabits();
                 addHabitForm.reset();
                 awardPoints(2); // Points for setting a habit
             });

            const toggleHabitComplete = (habitId, isChecked) => {
                const habit = data.habits.find(h => h.id === habitId);
                 if (!habit) return;
                 const today = todayISO();

                 if (isChecked) {
                      // Add today's date if not already present
                     if (!habit.completedDates.includes(today)) {
                         habit.completedDates.push(today);
                         habit.completedDates.sort(); // Keep sorted for streak calculation
                         awardPoints(POINTS_PER_HABIT);
                         showCompletionEffect(habitId);
                     }
                 } else {
                     // Remove today's date if present
                      const index = habit.completedDates.indexOf(today);
                     if (index > -1) {
                         habit.completedDates.splice(index, 1);
                         awardPoints(-POINTS_PER_HABIT);
                     }
                 }

                calculateHabitStreak(habit); // Recalculate streak
                 saveData();
                 renderHabits(); // Re-render to show updated state/streak
             };


            const calculateHabitStreak = (habit) => {
                let currentStreak = 0;
                 if (habit.completedDates.length === 0) {
                     habit.streak = 0;
                     return;
                 }

                const sortedDates = habit.completedDates.slice().sort().reverse(); // Newest first
                 const today = new Date(todayISO());
                 let expectedDate = new Date(today); // Start checking from today

                for (const dateStr of sortedDates) {
                    const completedDate = new Date(dateStr + 'T00:00:00'); // Ensure local timezone date object

                    // Check if the completed date matches the expected date in the sequence
                     if (completedDate.getTime() === expectedDate.getTime()) {
                         currentStreak++;
                         // Decrement expected date for the next check
                         expectedDate.setDate(expectedDate.getDate() - 1);
                     } else if (completedDate < expectedDate) {
                         // Found a gap, stop counting
                          break;
                      }
                      // Ignore future dates (shouldn't happen with check logic)
                }

                habit.streak = currentStreak;
                // Award streak badge
                if (currentStreak >= 5 && !BADGES['streak_master_5'].achieved) {
                     awardBadge('streak_master_5');
                }
            };

            // Calculate streaks for all habits periodically (e.g., on load or daily)
             const updateAllHabitStreaks = () => {
                 data.habits.forEach(habit => calculateHabitStreak(habit));
                 renderHabits(); // Update UI potentially
             };


             // --- Note Handling ---
             addNoteForm.addEventListener('submit', (e) => {
                e.preventDefault();
                 const title = noteTitleInput.value.trim();
                 const content = noteContentTextarea.value.trim();
                 const linkValue = noteLinkSelect.value;
                 let linkedItemId = null;
                 let linkedItemType = null;

                if (!title || !content) return;

                if(linkValue) {
                    const parts = linkValue.split('_');
                    linkedItemType = parts[0]; // 'goal' or 'task'
                    linkedItemId = parts[1];
                 }

                const newNote = {
                    id: generateId(),
                    title: title,
                    content: content,
                     linkedItemId: linkedItemId,
                    linkedItemType: linkedItemType,
                     created: new Date().toISOString()
                };
                data.notes.push(newNote);
                saveData();
                renderNotes();
                 addNoteForm.reset();
                 awardPoints(1); // Points for notes
             });


            // --- Pomodoro Timer ---
            const updateTimerDisplay = () => {
                const minutes = Math.floor(timerSeconds / 60);
                const seconds = timerSeconds % 60;
                timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
             };

             startTimerBtn.addEventListener('click', () => {
                 if (!timerRunning) {
                    timerRunning = true;
                     timerInterval = setInterval(() => {
                         timerSeconds--;
                         updateTimerDisplay();
                         if (timerSeconds <= 0) {
                             clearInterval(timerInterval);
                             timerRunning = false;
                             alert("Pomodoro Session Complete!"); // Simple notification
                             // Maybe add points here?
                             resetTimer(); // Reset for next session
                         }
                     }, 1000);
                 }
             });

             pauseTimerBtn.addEventListener('click', () => {
                 if (timerRunning) {
                     clearInterval(timerInterval);
                     timerRunning = false;
                 }
             });

             resetTimerBtn.addEventListener('click', () => {
                resetTimer();
             });

            const resetTimer = () => {
                clearInterval(timerInterval);
                timerRunning = false;
                timerSeconds = 25 * 60; // Reset to default
                updateTimerDisplay();
             };

            // --- Review Handling ---
            markReviewDoneBtn.addEventListener('click', () => {
                data.lastReviewDate = new Date().toISOString();
                awardPoints(POINTS_PER_REVIEW);
                saveData();
                 renderReviewStatus();
                alert("Review Marked as Complete!");
            });

            // --- Gamification Logic ---
             const awardPoints = (pointsToAdd) => {
                if (!pointsToAdd || pointsToAdd === 0) return;
                 const oldLevel = data.gamification.level;
                 data.gamification.points = Math.max(0, data.gamification.points + pointsToAdd); // Ensure points don't go below 0
                 updateLevel(); // Recalculate level based on new points

                // If level increased, show feedback
                 if(data.gamification.level > oldLevel) {
                    console.log(`Level Up! Reached Level ${data.gamification.level}`);
                    // Add more visual feedback for level up later
                 }

                 updateGamificationDisplays(); // Update UI elements
                 saveData(); // Save after points/level change
             };

            const updateLevel = () => {
                 data.gamification.level = Math.floor(data.gamification.points / POINTS_PER_LEVEL) + 1;
             };


             const awardBadge = (badgeId) => {
                  if (BADGES[badgeId] && !BADGES[badgeId].achieved) {
                     BADGES[badgeId].achieved = true; // Mark as achieved in the runtime structure
                     if (!data.gamification.badges.includes(badgeId)) {
                         data.gamification.badges.push(badgeId); // Add to persistent data
                         console.log(`Badge Awarded: ${BADGES[badgeId].name}!`);
                          saveData(); // Save immediately after awarding a badge
                          renderGamificationVisuals(); // Update display
                         // Maybe add a celebratory alert or visual effect
                     }
                 }
             };

             // Sync the BADGES runtime object with saved data on load
             const updateBadgeDataStructure = () => {
                 data.gamification.badges.forEach(badgeId => {
                     if (BADGES[badgeId]) {
                         BADGES[badgeId].achieved = true;
                     }
                 });
             };


             const updateGamificationDisplays = () => {
                pointsDisplay.textContent = data.gamification.points;
                levelDisplay.textContent = data.gamification.level;
                 renderGamificationVisuals(); // Update plant and badges too
             };


            // --- Theme Toggle ---
             const applyTheme = (themeName) => {
                 document.body.className = themeName === 'dark' ? 'dark-theme' : '';
                 data.settings.theme = themeName; // Update state
             };

             themeToggle.addEventListener('click', () => {
                const newTheme = data.settings.theme === 'light' ? 'dark' : 'light';
                 applyTheme(newTheme);
                 saveData(); // Save theme preference
             });


            // --- Navigation ---
             const showView = (viewId) => {
                 views.forEach(view => view.classList.remove('active'));
                 const activeView = document.getElementById(viewId);
                 if (activeView) activeView.classList.add('active');

                 navLinks.forEach(link => {
                     link.classList.remove('active');
                     if (link.dataset.view === viewId) {
                         link.classList.add('active');
                     }
                 });

                 // Perform actions needed when switching TO a view
                  if (viewId === 'calendar-view') renderCalendar();
                  if (viewId === 'habits-view') renderHabits();
                  if (viewId === 'notes-view') renderNotes();
                  if (viewId === 'reviews-view') renderReviewStatus();
                  if (viewId === 'inbox-view') renderInbox();
                  if (viewId === 'goals-view') renderGoalsAndTasks(); // Rerender to ensure structure is okay
                  if (viewId === 'today-focus-view') renderTodayFocus();

                  console.log("Switched to view:", viewId);
              };

              navLinks.forEach(link => {
                  link.addEventListener('click', (e) => {
                      e.preventDefault();
                      if (e.target.dataset.view) {
                          showView(e.target.dataset.view);
                      }
                  });
              });


            // --- Rendering Orchestration ---
            const renderAll = () => {
                renderGoalsAndTasks(); // Includes Today Focus update
                 renderInbox();
                 // Only render active view if needed for performance (though negligible here)
                 const activeViewId = document.querySelector('.view.active')?.id;
                  if (activeViewId === 'calendar-view') renderCalendar();
                 else if (activeViewId === 'habits-view') renderHabits();
                 else if (activeViewId === 'notes-view') renderNotes();
                 else if (activeViewId === 'reviews-view') renderReviewStatus();

                updateGamificationDisplays();
                updateContextSelects(); // Ensure context dropdowns are up-to-date
                 console.log("RenderAll completed");
             };

            // --- Initialization ---
            loadData();
             updateAllHabitStreaks(); // Calculate streaks on load
             renderAll(); // Render UI based on loaded data
             resetTimer(); // Initialize timer display
            showView('goals-view'); // Set initial view


            // --- Form Listeners ---
             addItemForm.addEventListener('submit', handleAddItemSubmit);
             addInboxForm.addEventListener('submit', handleAddInboxSubmit);
             addHabitForm.addEventListener('submit', handleAddItemSubmit); // Re-use if form structure allows or write specific handler
             addNoteForm.addEventListener('submit', handleAddItemSubmit); // Re-use or write specific

            console.log("NexusFlow Enhanced Initialized. Data:", data);

        }); // End DOMContentLoaded
    </script>

</body>
</html>
